<style>
    .w-100 {
        width: 100%;
    }
</style>

<aside class="w-100">
    <h3> 不要优化 </h3>
    <p> 抽象和分离使您的程序进化得更快更容易，但是不要浪费时间去做它们，除非您确信所讨论的代码需要这种灵活性。  </p>
    <p> 开发过程中，要确认你的项目类型、模块大小以及代码生命周期，确认当前代码值得</p>
    <details>
        <summary>详解</summary>
        <p> 不要过早的优化，事不过三，三则优化。多写一点代码无所谓，千万别给自己找事做。如果你确认未来很难发生变化，在开发中上尽量保持简单和愚蠢。 </p>
    </details>
</aside>

<aside class="w-100">
    <h3>动静分离</h3>
    <p>当前的动静分离并不是指代静态请求和动态请求，而是将开发中的容易修改的代码和不易修改的代码分离开。</p>
    <p> 分离后，在开发中，编译和打包时间大大缩短。虽然 bundleless, vite 可以解决这些问题，但实质上，如此拆分实际上在整个项目上实现了单一职责。</p>
      <details>
         <summary>详解</summary>
           <p>可以把项目中改动较少的的基础服务以及封装的业务组件给提取出去。利用 Webpack 的 externals 来辅助开发。</p>
           <p>责任与义务本质上就是对等的，且越对等的就越稳定。这几年，微服务架构，中台，微前端理论层出不穷，本质上就是为了权责对等，对于更加基础的服务，更有产出的业务投入更高的人力与物力以保证更稳定的运行是很正常的一件事。而不是之前的大锅饭(单体应用)。</p>
       </details>
    <h4>好例子</h4>
    <code class="w-100">
     <pre>
/** 第三方依赖 */
&lt; script src=//unpkg.com/vue@2.6.11/dist/vue.min.js crossorigin=anonymous&gt;&lt;/script&gt;
/** 基础依赖 */
&lt; script src=/js/base.js crossorigin=anonymous&gt;&lt;/script&gt;
/** 义务依赖(可以依赖基础依赖) */
&lt; script src=/js/business.js crossorigin=anonymous&gt;&lt;/script&gt;
/** 后续依赖 */
      </pre>
     </code>

</aside>


<aside class="w-100">
    <h3> 允许巧合 </h3>
    <p> DRY(不要重复自己)，当践行 DRY 的时候，往往意味着需求变更后仅仅只需要修改一处即可以满足实际需求。  </p>
    <p> 但并非所有的代码重复都是知识的重复，销售和采购是两个业务，但这两个业务线中会有大量的重复代码。 </p>
    <p> 此代码的重复并非知识的重复，仅仅只是一种巧合。 </p>
    <details>
         <summary>详解</summary>
         <p> 不要过早的抽象业务代码，甚至不要抽象业务代码。多写一点代码无所谓，千万别给自己找事做。 在业务上尽量保持简单和愚蠢。除非你是业务专家，确认当前业务不太会产生变化。 </p>
         <p> 你无法确认当前项目是否会拆分为多个项目，甚至会演变成多个项目组。此时你要做的是把知识抽离出来，但也要允许巧合(即使你要修改多处代码)。 </p>
    </details>
</aside>
